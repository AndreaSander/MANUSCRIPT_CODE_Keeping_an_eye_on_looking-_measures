---
title: "Peekbank"
output: html_document
date: "2024-10-23"
---

```{r setup, include=FALSE}

library(tidyverse)
library(dbplyr)
library(tidylog)
library(here)
library(Hmisc)
library(corrplot)
library(psych)

`%notin%` <- negate(`%in%`)
options(scipen = 999)

```

#Combine data
#### ONLY NEED TO RUN THIS CHUNK ONCE, OR AGAIN IF SOMETHING CHANGES IN THE CLEANING SCRIPTS
```{r}

#Only need to run this chunk once, or again if something changes in the cleaning scripts


#In order to have the plots from different data sources laid out next to each other how we want, we'll have to put the data all together into large datasets. WARNING: these data frames will have REPEATED ROWS, because they contain all the rows from distractor-initial trials, all the rows from target-initial trials, and then all of those rows again labelled as "all". So do not do any analysis or manipulations without grouping or filtering by the data_split variable!

data_list_by_subject <- list()
data_list_by_trial <- list()

for (i in c("experimental", "non-experimental", "both_types")) {
  for (j in c("target", "distractor", "all")) {
    #get anon_archival
    data_new_dvs_by_subject_arch <- read_csv(here(paste0(
      "all_variables_datasets/archival_by_subject_means_sds_", 
                                                    i, "_", j, ".csv")))
    data_new_dvs_by_trial_arch <- read_csv(here(paste0(
      "all_variables_datasets/archival_by_trial_means_sds_", 
                                                  i, "_", j, ".csv")))
    
    #get peekbank
    data_new_dvs_by_subject_pb <- read_csv(here(paste0(
      "all_variables_datasets/peekbank_by_subject_means_sds_", 
                                                    i, "_", j, ".csv")))
    data_new_dvs_by_trial_pb <- read_csv(here(paste0(
      "all_variables_datasets/peekbank_by_trial_means_sds_", 
                                                  i, "_", j, ".csv")))
    #bind together
    
    #by subject
    data_by_subject <- data_new_dvs_by_subject_arch %>%
      mutate(data_source = "archival",
             exp_type = i) %>%
      bind_rows(data_new_dvs_by_subject_pb %>% mutate(data_source = "peekbank", exp_type = i)) 
    #by trial
    data_by_trial <- data_new_dvs_by_trial_arch %>%
      mutate(data_source = "archival",
             exp_type = i) %>%
      bind_rows(data_new_dvs_by_trial_pb %>% mutate(data_source = "peekbank", exp_type = i))
    
    #add to list
    data_list_by_subject[paste0(i, "_", j)] <- list(data_by_subject)
    data_list_by_trial[paste0(i, "_", j)] <- list(data_by_trial)
    
  }
}

bind_rows(data_list_by_subject, .id = "data_split_id") %>% 
  write_csv(here(paste0("all_variables_datasets/combined_datasets/by_subject.csv")))

bind_rows(data_list_by_trial, .id = "data_split_id") %>% 
  write_csv(here(paste0("all_variables_datasets/combined_datasets/by_trial.csv")))


```


#Get data

```{r}
#Remove fmw_2013 from the data since there are some odd data discrepancies we can't resolve
data_by_subject <- read_csv(here(paste0("all_variables_datasets/combined_datasets/by_subject.csv"))) %>%
  filter(dataset_name != "fmw_2013")
data_by_trial <- read_csv(here(paste0("all_variables_datasets/combined_datasets/by_trial.csv"))) %>%
  filter(dataset_name != "fmw_2013")
print_list <- list()

```

#Correlations
```{r}

#-------------------------------------------------------------Analysis steps begin here

#dplyr::select only numerical variables for correlation

#PEARSON CORRELATION
for_correlation_with_age <- data_by_subject %>%
  #want to keep both experimental types
  filter(exp_type != "both_types") %>%
  #want to keep target and distractor
  filter(data_split == "all") %>%
  dplyr::select(-(starts_with("sd")), -(starts_with("n_trials")), -(ends_with("centred")), -subject_id, -ends_with("exp")) %>%
  dplyr::select(where(is.numeric), data_split_id, data_source) %>%
  split(f = paste0(.$data_split_id, "_", .$data_source))


cor_matrices_pearson <- list()
not_all_na <- function(x) any(!is.na(x))

for (i in 1:length(for_correlation_with_age)) {
  data <- for_correlation_with_age[[i]] %>%
    select(where(is.numeric)) %>%
    select_if(not_all_na)
  element <- names(for_correlation_with_age[i])
  cor_matrix <- cor(x=data, use="pairwise.complete.obs")
  cor_matrices_pearson[paste0(element)] <- list(cor_matrix)
}

# Extract p-values

p_values <- list()

for (i in 1:length(for_correlation_with_age)) {
  data <- for_correlation_with_age[[i]] %>%
    select(where(is.numeric)) %>%
    select_if(not_all_na)
  element <- names(for_correlation_with_age[i])
  cor_matrix <- rcorr(x=as.matrix(data))$P
  p_values[paste0(element)] <- list(cor_matrix)
} 


#adjust for multiple comparisons

p_values_adjusted <- list()

for (i in 1:length(p_values)) {
  element <- names(p_values[i])
  # Flatten the matrix to adjust p-values
  p_values_flat <- as.vector(p_values[[i]])
  # Adjust p-values using Bonferroni correction
  p_values_adj <- p.adjust(p_values_flat, method = "bonferroni")
  # Convert the adjusted p-values back to a matrix
  p_values_adj_matrix <- matrix(p_values_adj, ncol = ncol(p_values[[i]]))
  p_values_adjusted[paste0(element)] <- list(p_values_adj_matrix)
} 


#plotting the correlations

#Change column and row names to look nicer on plot in real words

better_names <- data.frame(
  old_name = c("age_months", "exp_to_target_lang", "fre_exp", "eng_exp", "mean_prop_looking", "mean_prop_looking_diff", "mean_number_fixations", "mean_prop_shift_target_initial", "mean_prop_shift_distractor_initial", "mean_RT", "mean_aoi_switches", "mean_duration_of_look", "mean_first_look_dur", "mean_longest_look", "mean_peak_pupil_size_difference", "mean_mean_pupil_size_difference", "mean_peak_pupil_latency"),
  new_name = c("Age in months", "Target language exposure", "French exposure", "English exposure", "Proportion looking", "Proportion looking difference", "Total number of fixations", "Proportion trials staying on target", "Proportion trials shifting to target", "Reaction time", "Mean number of AOI switches", "Mean duration of looks", "Mean duration of first look", "Duration of longest look", "Peak pupil size difference", "Mean pupil size difference", "Peak pupil latency"))

var_order <- c("Age in months", "Proportion looking", "Proportion looking difference", "Total number of fixations", "Proportion trials staying on target", "Proportion trials shifting to target", "Reaction time", "Mean number of AOI switches", "Mean duration of looks", "Mean duration of first look", "Duration of longest look", "Peak pupil size difference", "Mean pupil size difference", "Peak pupil latency", "Target language exposure")

# Create a lookup vector from the IDs/Names dataframe
lookup_names <- better_names$new_name
names(lookup_names) <- better_names$old_name

for (i in 1:length(cor_matrices_pearson)) {
  element <- names(cor_matrices_pearson[i])
  matrix <- cor_matrices_pearson[[i]]
  colnames(matrix) <- lookup_names[colnames(matrix)]
  rownames(matrix) <- lookup_names[rownames(matrix)]
  cor_matrices_pearson[paste0(element)] <- list(matrix)
}


print_list[[paste("Pearson Correlations")]] <- cor_matrices_pearson


#--------------------------------Plots

#--------------------------------------------PEARSON

#function to plot from a list of plots using patchwork
plot_a_list <- function(master_list_with_plots, no_of_rows, no_of_cols) {

  patchwork::wrap_plots(master_list_with_plots, 
                        nrow = no_of_rows, ncol = no_of_cols)
}

cor_plots_data <- list()
for (i in 1:length(cor_matrices_pearson)) {
  element <- names(cor_matrices_pearson[i])
  data <- cor_matrices_pearson[[i]] %>% 
  as_tibble() %>%
    mutate(var2 = rownames(cor_matrices_pearson[[i]])) %>% 
    pivot_longer(-var2, names_to = "var1", values_to = "corr")
  cor_plots_data[[paste0(element)]] <- data
  
}

corr_plots <- list()

for ( i in 1:length(cor_plots_data)) {
  
  data <- cor_plots_data[[i]]
  name <- names(cor_plots_data[i])

  if (name == "non-experimental_all_archival") {
    axis_text_x <- element_blank()
    axis_text_y <- element_text()
  } else if (name == "non-experimental_all_peekbank") {
    axis_text_x <- element_blank()
    axis_text_y <- element_blank()
  } else if (name == "experimental_all_archival") {
    axis_text_x <- element_text(angle = 45,
                                       hjust = 1)
    
    axis_text_y <- element_text()
  } else if (name == "experimental_all_peekbank") {
    axis_text_x <- element_text(angle = 45,
                                       hjust = 1)
    axis_text_y <- element_blank()
  }
  
  plot <- data %>%
      ggplot(aes(
      x=factor(var1, levels = var_order),
      y=factor(var2, levels = rev(var_order)))) +
      geom_point(aes(size = abs(corr), fill = corr),
                 shape = 21, color = "darkgrey") +
      scale_fill_gradient2(low = "#8E0152", midpoint = 0, mid = "white", high = "#276419",
                            limits = c(-1, 1),
                            breaks=c(-1,-.5,0,.5,1)) +
      scale_size_continuous(range = c(1, 6)) +
    scale_x_discrete(drop = FALSE) +
    scale_y_discrete(drop = FALSE) +
      guides(size="none") +
      labs(x = NULL, y = NULL) +
      coord_cartesian() +
      theme_bw() +
      theme(axis.text.x = axis_text_x,
            axis.text.y = axis_text_y,
            aspect.ratio=1) +
      ggtitle(paste0(
        #Remove this str_replace to de-anonymize
        str_replace(
          str_to_title(
            str_replace_all(
              str_replace(
                str_replace(name, "non-experimental", "familiar"), 
                "_all", ""), 
              "_", ", ")), 
          #Remove this str_replace to de-anonymize
            "Archival", "ANONYM")))

  
  corr_plots[[paste(name)]] <- plot
}

plot_order <- c("non-experimental_all_archival", "non-experimental_all_peekbank", "experimental_all_archival", "experimental_all_peekbank")

#Plots
plot_a_list(c(corr_plots[plot_order]), 2, 2) +
  patchwork::plot_layout(guides = 'collect') 

ggsave(here::here(paste0("figures/correlation_plots.png")), width = 9, height = 9)


#--------------------------------------------SPEARMAN
#SPEARMAN CORRELATION

cor_matrices_spearman <- list()

for (i in 1:length(for_correlation_with_age)) {
  data <- for_correlation_with_age[[i]] %>%
    select(where(is.numeric)) %>%
    select_if(not_all_na)
  element <- names(for_correlation_with_age[i])
  cor_matrix <- cor(x=data, use="pairwise.complete.obs", method = "spearman")
  cor_matrices_spearman[paste0(element)] <- list(cor_matrix)
}

for (i in 1:length(cor_matrices_spearman)) {
  element <- names(cor_matrices_spearman[i])
  matrix <- cor_matrices_spearman[[i]]
  colnames(matrix) <- lookup_names[colnames(matrix)]
  rownames(matrix) <- lookup_names[rownames(matrix)]
  cor_matrices_spearman[paste0(element)] <- list(matrix)
}

corr_plots_data_sp <- list()
for (i in 1:length(cor_matrices_spearman)) {
  element <- names(cor_matrices_spearman[i])
  data <- cor_matrices_spearman[[i]] %>% 
  as_tibble() %>%
    mutate(var2 = rownames(cor_matrices_spearman[[i]])) %>% 
    pivot_longer(-var2, names_to = "var1", values_to = "corr")
  corr_plots_data_sp[[paste0(element)]] <- data
  
}

corr_plots_sp <- list()

for ( i in 1:length(corr_plots_data_sp)) {
  
  data <- corr_plots_data_sp[[i]]
  name <- names(corr_plots_data_sp[i])

  if (name == "non-experimental_all_archival") {
    axis_text_x <- element_blank()
    axis_text_y <- element_text()
  } else if (name == "non-experimental_all_peekbank") {
    axis_text_x <- element_blank()
    axis_text_y <- element_blank()
  } else if (name == "experimental_all_archival") {
    axis_text_x <- element_text(angle = 45,
                                       hjust = 1)
    
    axis_text_y <- element_text()
  } else if (name == "experimental_all_peekbank") {
    axis_text_x <- element_text(angle = 45,
                                       hjust = 1)
    axis_text_y <- element_blank()
  }
  
  plot <- data %>%
      ggplot(aes(
      x=factor(var1, levels = var_order),
      y=factor(var2, levels = rev(var_order)))) +
      geom_point(aes(size = abs(corr), fill = corr),
                 shape = 21, color = "darkgrey") +
      scale_fill_gradient2(low = "#8E0152", midpoint = 0, mid = "white", high = "#276419",
                            limits = c(-1, 1),
                            breaks=c(-1,-.5,0,.5,1)) +
      scale_size_continuous(range = c(1, 6)) +
    scale_x_discrete(drop = FALSE) +
    scale_y_discrete(drop = FALSE) +
      guides(size="none") +
      labs(x = NULL, y = NULL) +
      coord_cartesian() +
      theme_bw() +
      theme(axis.text.x = axis_text_x,
            axis.text.y = axis_text_y,
            aspect.ratio=1) +
       ggtitle(paste0(
        #Remove this str_replace to de-anonymize
        str_replace(
          str_to_title(
            str_replace_all(
              str_replace(
                str_replace(name, "non-experimental", "familiar"), 
                "_all", ""), 
              "_", ", ")), 
          #Remove this str_replace to de-anonymize
            "Archival", "ANONYM")))

  
  corr_plots_sp[[paste(name)]] <- plot
}


#Plots
plot_a_list(c(corr_plots_sp[plot_order]), 2, 2) +
  patchwork::plot_layout(guides = 'collect') 

ggsave(here::here(paste0("figures/correlation_plots_SPEARMAN.png")), width = 9, height = 9)

print_list[[paste("Spearman Correlations:")]] <- cor_matrices_spearman


```

#Factor Analysis  
```{r}

#------------------------------------------Factor analysis

#------------------------Get relevant rows and columns for data

#------------All variables except age
for_factor_analysis <- list()

for (i in 1:length(cor_matrices_pearson)) {
  #get rid of lang exposure and age varaibles
  data <- cor_matrices_pearson[[i]] 
  element <- names(cor_matrices_pearson[i])
  data <- data[!rownames(data) %in% c("Age in months", "Target language exposure"), !colnames(data) %in% c("Age in months", "Target language exposure")]
  for_factor_analysis[paste0(element)] <- list(data)
}

#------------------------check how many factors we should use

eigenvalue_plots <- list()

for (i in 1:length(for_factor_analysis)) {
  data <- for_factor_analysis[[i]] 
  element <- names(for_factor_analysis[i])
  #We are sticking with ss loads above 1 so that leaves us with 2 factors.
  scree = data.frame(factor_n = 1:ncol(data), eigenvalue = eigen(data)$values)
  screeplot <- ggplot(scree, aes(x=factor_n, y = eigenvalue)) +
                geom_point() +
                geom_line() +
                geom_hline(yintercept=1,color = "red") +
                xlab("# factors") +
                ylab("eigenvalue") +
                ggtitle(paste("Scree Plot", element))
  eigenvalue_plots[paste0(element)] <- list(screeplot)
}

plot_a_list(eigenvalue_plots, 3, 4) +
  patchwork::plot_layout(guides = 'collect') 

#With all variables
factor_analyses <- list()

for (i in 1:length(for_factor_analysis)) {
  #looking at the eigen plots, use 3 factors for peekbank and 4 for archival
  nfct <- ifelse(str_detect(names(for_factor_analysis[i]), "archival"), 4, 3)
  data <- for_factor_analysis[[i]] %>%
    as_tibble() %>% 
    dplyr::select(where(is.numeric)) %>%
    select_if(not_all_na) %>%
    as.matrix()
  rownames(data) <- colnames(data)
  element <- names(for_factor_analysis[i])
  #We are sticking with ss loads above 1 so that leaves us with 2 factors.
  fct_ana <- psych::fac(data, nfactors = nfct)
  factor_analyses[paste0(element)] <- list(fct_ana)
}


#Proportion looking tends to be good because it considers both distractor initial and target initial trials. But there are other variables like number of fixations that might be good but just for certain types of trials e.g. target initial.

#Pupil is cool as a measure of surprise if they are looking at the wrong thing (distractor initial) but not during target initial trials.

#We want to ultimately give reccomendations. Is there a measure that's more robust, best for manipulations, if it only works for a type of trial, like target initial you are halving your data, so is that best? We might run reliability measures by child by trial.

```

#ICC
```{r}
#--------------------------------------ICC

# Before, we were splitting by peekbank vs archival, exp vs non-exp, and also initial look
# data_by_trial_split <- data_by_trial %>%
#   split(f = paste0(.$data_split_id, "_", .$data_source))

#Now, we aren't splitting, but for the "all" subsection, recode data_split as "all_initial_looks". Only need the "both_types" of experiment type
data_by_trial_icc <- data_by_trial %>%
  #ICC to be done on familiar trials only
  filter(exp_type == "non-experimental") %>%
  mutate(data_split = case_when(data_split == "all" ~ "all_initial_looks",
                                TRUE ~ data_split))

possible_columns <- c("prop_looking", "prop_looking_diff", "number_fixations", "correct_shift", "remain_on_target", "latency_to_switch", "total_aoi_switches", "duration_of_look", "first_look_dur", "longest_look_by_trial", "peak_pupil_size_difference", "mean_pupil_size_difference", "peak_pupil_latency")

fct_lvls <- c("Proportion looking", "Proportion looking difference", "Number fixations", "Proportion trials shifting to target", "Proportion trials staying on target", "Reaction time", "Number of AOI switches", "Mean duration of all looks", "Duration of first look", "Duration of longest look", "Peak pupil size difference", "Mean pupil size difference", "Peak pupil latency")
  
  #HK note: below I have calculated the ICC for all variables with the same code chunk, however, when it runs, we are getting quite a few singular fit warnings

#Run ICC by study, then average for the plot (like how the black diamonds are for the old version of the plot)

# icc <- data_by_trial_icc %>%
#     dplyr::select(c(recording_name, dataset_name, data_split, any_of(possible_columns))) %>%
#     janitor::remove_empty() %>% 
#     pivot_longer(4:ncol(.), names_to = "variable", values_to = "response") %>%
#   filter(!(dataset_name == "garrison_bergelson_2020" & variable == "first_look_dur" & data_split == "distractor")) %>%
#     group_by(data_split, recording_name, variable) %>%
#     mutate(ntrial = row_number()) %>%
#     pivot_wider(names_from = ntrial, values_from = response) %>%
#   ungroup() %>% 
#     filter(if_any(5:ncol(.), complete.cases)) %>% #drop rows with all NAs (some studies don't have info for prop looking difference)
#     group_by(dataset_name, data_split, variable) %>%
#     group_modify(~tibble(icc = as.data.frame(list(ICC(.x[sapply(.x, is.numeric)], missing = FALSE, lmer = TRUE, alpha = 0.05)$results))) %>% filter(icc$type == "ICC3k") %>% mutate(rater_type = "Average_fixed_raters")) %>%
#     unnest(icc) %>%
#   mutate(SE = (upper.bound - lower.bound) / 3.92) %>%
#   split(f = paste0(.$data_split, ".", .$variable))

#new code to calculate pooled ICC while removing all the NA columns for each study
icc_data <- data_by_trial_icc %>%
    dplyr::select(c(recording_name, dataset_name, data_split, any_of(possible_columns))) %>%
    janitor::remove_empty() %>% 
    pivot_longer(4:ncol(.), names_to = "variable", values_to = "response") %>%
  #filter(!(dataset_name == "garrison_bergelson_2020" & variable == "first_look_dur")) %>%
    group_by(data_split, recording_name, variable) %>%
    mutate(ntrial = row_number()) %>%
    pivot_wider(names_from = ntrial, values_from = response) %>%
  ungroup() %>% 
    filter(if_any(5:ncol(.), complete.cases)) %>%
  split(f = paste0(.$dataset_name, ".", .$data_split, ".", .$variable))

icc_by_study_by_var <- list()

for (i in 1:length(icc_data)) {
  
  element <- names(icc_data[i])
  
  #one subset doesn't have enough non-NA values to compute the ICC, so only run for the other ones
  if (element != "garrison_bergelson_2020.distractor.first_look_dur") {
  curr_data <- icc_data[[i]] %>%
    #get rid of columns that are all NA
    select(where(not_all_na)) %>%
    select(where(is.numeric))
  
  curr_iccs <- ICC(curr_data, missing = FALSE, lmer = TRUE, alpha = 0.05)$results
  
  z_and_variance <- metafor::escalc(measure = "COR", ri = curr_iccs$ICC, ni = (curr_iccs$df1+1))
  
  curr_iccs <- curr_iccs %>%
    bind_cols(z_and_variance) %>%
    mutate(rater_type = rownames(.),
           dataset_name = str_remove(element, "\\..*"),
           initial_look = str_extract(element, "(?<=\\.).*(?=\\.)"),
           variable = str_remove(element, ".*\\.")) %>%
    filter(rater_type == "Average_fixed_raters")

  icc_by_study_by_var[[paste0(element)]] <- curr_iccs
  }
}

icc_by_var_by_look <- bind_rows(icc_by_study_by_var) %>%
  #remove All Looks subset for variables that are target or distractor initial only
  filter(!(initial_look == "all_initial_looks" & variable %in% c("correct_shift", "latency_to_switch", "remain_on_target"))) %>% 
  split(f = paste0(.$variable, ".", .$initial_look))

pooled_icc <- list()

for (i in 1:length(icc_by_var_by_look)) {
  
  element <- names(icc_by_var_by_look[i])
  data <- icc_by_var_by_look[[i]] 
  meta_icc <- metafor::rma(yi, vi, data = data)
  meta_values <- tibble(var = element,
                        pooled_effect = meta_icc$beta[[1]],
                        ci_low = meta_icc$ci.lb,
                        ci_high = meta_icc$ci.ub,
                        p_val = meta_icc$pval)
  pooled_icc[[paste0(element)]] <- meta_values
}

#use inverse variance weighting to pool ICCs
# pooled_icc <- list()
# 
# for (i in 1:length(icc)) {
#   element <- names(icc[i])
#   data <- icc[[i]] 
#   gen <- metafor::escalc(measure = "MN", 
#                          mi = ICC,
#                          sei = SE,
#                          data = data) 
#   
#   pooled_icc[paste0(element)] <- list(gen)
#     
# }
# 
# means_cis_icc <- list()
# 
# for (i in 1:length(pooled_icc)) {
#   
#   element <- names(pooled_icc[i])
#   data <- pooled_icc[[i]]
#   vals <- metafor::rma(yi, vi, data = data)
#   meta_values <- tibble(var = element,
#                         pooled_effect = vals$beta[[1]],
#                         ci_low = vals$ci.lb,
#                         ci_high = vals$ci.ub,
#                         p_val = vals$pval)
#   means_cis_icc[[paste0(element)]] <- meta_values
#   
#}

fct_lvls <- c("Proportion looking", "Proportion looking difference", "Number fixations", "Proportion trials shifting to target", "Proportion trials staying on target", "Reaction time", "Number of AOI switches", "Mean duration of all looks", "Duration of first look", "Duration of longest look", "Peak pupil size difference", "Mean pupil size difference", "Peak pupil latency")

pooled_icc_for_plot <- pooled_icc %>%
  bind_rows() %>%
  separate(var, into = c("variable", "data_split"), sep = "\\.") %>%
  mutate(variable = case_when(variable == "latency_to_switch" ~ "Reaction time",
                              variable == "duration_of_look" ~ "Mean duration of all looks",
                              variable == "first_look_dur" ~ "Duration of first look",
                              variable == "longest_look_by_trial" ~ "Duration of longest look",
                              variable == "correct_shift" ~ "Proportion trials shifting to target",
                              variable == "remain_on_target" ~ "Proportion trials staying on target",
                              variable == "prop_looking" ~ "Proportion looking",
                              variable == "prop_looking_diff" ~ "Proportion looking difference",
                              variable == "total_aoi_switches" ~ "Number of AOI switches",
                              TRUE ~ snakecase::to_sentence_case(variable)),
         data_split = case_when(data_split == "all_initial_looks" ~ "Combined",
                                TRUE ~ snakecase::to_sentence_case(data_split)),
         
         data_split = factor(snakecase::to_sentence_case(data_split), levels = c("Target", "Distractor", "Combined")),
         var_ordered = factor(variable, levels = fct_lvls, ordered = T))


pooled_icc_for_plot %>%
  ggplot(aes(x = pooled_effect, y = fct_rev(var_ordered), color = data_split)) +
  geom_vline(xintercept = 0, color = "#777777", linetype = "dotted") +
  geom_errorbar(aes(xmin = ci_low, xmax = ci_high), alpha = .75, width = .25) +
  geom_point(size=4, alpha = .75, shape = 18)+
  #geom_errorbarh(aes(xmin=all_dvs_c$CI_lower, xmax=all_dvs_c$CI_upper))+
  labs(x = "Pooled ICC",
       y = "Variable",
       title = "Distribution of ICC by variable and initial look location",
       color = "Initial look location") +
  theme_minimal()+
  theme(plot.background = element_rect(fill = "white"),
        panel.spacing = unit(2, "lines"),
        panel.grid = element_line(color = "#EEEEFF")) +
  scale_x_continuous(limits = c(-.125,1)) +
  scale_color_manual(values = c("#438e32", "#c82a85", "#333333")) 


ggsave(here::here(paste0("figures/icc_plot.png")), width = 8, height = 5)

print_list[[paste("ICC:")]] <- icc_by_var_by_look

```

#Models - LM

```{r}

#HK note.... all these models have lang exposure as a factor.... not sure how to make them comparable to our dataset models without that variable

data_by_subject_long_split <- data_by_subject %>%
  #filter(exp_type == "both_types") %>%
  dplyr::select(data_split, data_source, exp_type, dataset_name, subject_id, age_months, age_months_centred, exp_to_target_lang, eng_exp, fre_exp, starts_with("mean")) %>%
  pivot_longer(11:ncol(.), names_to = "variable", values_to = "response") %>%
  split(f = paste0(.$data_split, "_", .$exp_type, "_", .$data_source, "_", .$variable))

list_levels_1 <- unique(str_extract(str_replace(names(data_by_subject_long_split), "mean_mean", "mean"), ".*(?=_mean)"))

#create list structure to house models and model summaries
#------------models
models <- list()
models[list_levels_1] <- list(NULL)

list_levels_2 <- list(simple = NULL,
                      inter = NULL)

for (i in 1:length(models)) {
  models[[i]] <- list_levels_2
}
#------------model summaries
model_summaries <- list()
model_summaries[list_levels_1] <- list(NULL)

for (i in 1:length(model_summaries)) {
  model_summaries[[i]] <- list_levels_2
}
#------------plots
inter_plots <- list()

for (i in 1:length(data_by_subject_long_split)) {
  data <- data_by_subject_long_split[[i]] 
  element <- str_extract(str_replace(names(data_by_subject_long_split[i]), "mean_mean", "mean"), ".*(?=_mean)")
  var_name <- unique(data$variable)
  
  #Skip the loop for variables that area all NA (like the pupil ones in the peekbank data)
  if (sjmisc::all_na(data$response)) {
    next
  } else {
    
    #For archival data only, include lang exposure
    if (str_detect(element, "archival")) {
      
        data$exp_to_target_lang_centred <- (data$exp_to_target_lang/100)-.5
        #Simple model
        simple_mod <- lm.beta::lm.beta(lm(response ~ age_months_centred + exp_to_target_lang_centred,  
                                  data = data))
        simple_mod_sum <- summary(simple_mod)
        #Interaction model
        inter_mod <- lm.beta::lm.beta(lm(response ~ age_months_centred*exp_to_target_lang_centred,
                                    data = data))
        inter_mod_sum <- summary(inter_mod)
        #interaction plot
        inter_plot <- interactions::interact_plot(inter_mod, pred= exp_to_target_lang_centred, modx=age_months_centred, plot.points = T) + 
          ggtitle(paste0(str_replace(element, "all_archival_", "archival"), "\n", var_name)) + 
          theme(plot.background = element_rect(colour = "grey", fill=NA))
        
        #LMEM
        simple_lmem <- sjstats::std_beta(lmer(response ~ age_months_centred + exp_to_target_lang_centred + (1|site/block),  
                                  data = data))
        simple_lmem_sum <- summary(simple_lmem)
        
        add_simple <- list(simple_mod)
        names(add_simple) <- var_name
        models[[paste0(element)]]$simple <- c(models[[paste0(element)]]$simple, add_simple)
        
        add_inter = list(inter_mod)
        names(add_inter) <- var_name
        models[[paste0(element)]]$inter <- c(models[[paste0(element)]]$inter, add_inter)
        
        add_simple_sum = list(simple_mod_sum)
        names(add_simple_sum) <- var_name
        model_summaries[[paste0(element)]]$simple <- c(model_summaries[[paste0(element)]]$simple, add_simple_sum)
        
        add_inter_sum = list(inter_mod_sum)
        names(add_inter_sum) <- var_name
        model_summaries[[paste0(element)]]$inter <- c(model_summaries[[paste0(element)]]$inter, add_inter_sum)
        
        inter_plots[paste0(element, "_", var_name)] <- list(inter_plot)
    } else {
        #Simple model with only age
        simple_mod <- lm.beta::lm.beta(lm(response ~ age_months_centred,  
                                  data = data))
        simple_mod_sum <- summary(simple_mod)
      
        add_simple = list(simple_mod)
        names(add_simple) <- var_name
        models[[paste0(element)]]$simple <- c(models[[paste0(element)]]$simple, add_simple)
        
        add_simple_sum = list(simple_mod_sum)
        names(add_simple_sum) <- var_name
        model_summaries[[paste0(element)]]$simple <- c(model_summaries[[paste0(element)]]$simple, add_simple_sum)
    }
  }
}

plot_a_list(inter_plots, 12, 9) +
  patchwork::plot_layout(guides = 'collect') 
ggsave(here("figures/interaction_plots.png"), height = 30, width = 15)

mod_comparisons_simple <- list()
mod_comparisons_inter <- list()
## Contrasting model performance
for (i in 1:length(models)) {
  level <- names(models)[i]
  compare_simple <- performance::compare_performance(models[[i]]$simple)
  mod_comparisons_simple[[paste0(level)]] <- compare_simple
  if(str_detect(level, "archival")) {
    compare_inter <- performance::compare_performance(models[[i]]$simple)
    mod_comparisons_inter[[paste0(level)]] <- compare_inter
  }
  
}

#---------------------------------Familiar trial models data vis for paper

non_exp_model_summaries <- model_summaries[str_detect(names(models), "non-exp")]

summaries_for_plot <- list()

for (i in 1:length(non_exp_model_summaries)) {
  element <- names(non_exp_model_summaries[i])
  summaries <- non_exp_model_summaries[[i]]$simple
  for (j in 1:length(summaries)) {
    summary <- summaries[[j]]
    variable <- names(summaries[j])
    summary_tidy <- as_tibble(summary$coefficients, rownames = "term") %>% 
      janitor::clean_names() %>% 
      mutate(pr_t = round(pr_t, digits = 6),
             model = paste(element, variable, sep = "_"))
    summaries_for_plot[paste0(element, "_", variable)] <- list(summary_tidy)
  }
}

fct_lvls <- c("Proportion looking", "Proportion looking difference", "Number fixations", "Proportion trials shifting to target", "Proportion trials staying on target", "Reaction time", "Number of AOI switches", "Duration of all looks", "Duration of first look", "Duration of longest look", "Peak pupil size difference", "Mean pupil size difference", "Peak pupil latency")

cleaned_plot_data <- summaries_for_plot %>%
  bind_rows() %>%
  filter(!str_detect(term, "Intercept")) %>% 
  mutate(initial_look = str_extract(model, ".*(?=_non)"),
         dataset = str_extract(model, "archival|peekbank"),
         variable = str_extract(model, "(?<=archival_|peekbank_).*"),
         variable = str_remove(variable, "mean_"),
         term = case_when(str_detect(term, "age_") ~ "Age",
                          str_detect(term, "exp_") ~ "Language\nexposure"),
         #remove the str_replace here to de-anonymize
         dataset = str_replace(str_to_title(dataset), "Archival", "ANONYM")) %>% 
  mutate(variable = case_when(variable == "RT" ~ "Reaction time",
                              variable == "duration_of_look" ~ "Duration of all looks",
                              variable == "first_look_dur" ~ "Duration of first look",
                              variable == "longest_look" ~ "Duration of longest look",
                              variable == "prop_shift_distractor_initial" ~ "Proportion trials shifting to target",
                              variable == "prop_shift_target_initial" ~ "Proportion trials staying on target",
                              variable == "prop_looking" ~ "Proportion looking",
                              variable == "prop_looking_diff" ~ "Proportion looking difference",
                              variable == "aoi_switches" ~ "Number of AOI switches",
                              TRUE ~ snakecase::to_sentence_case(variable)),
         initial_look = case_when(initial_look == "all" ~ "All initial looks",
                                TRUE ~ snakecase::to_sentence_case(initial_look)),
         
         data_split = factor(snakecase::to_sentence_case(initial_look), levels = c("Target", "Distractor", "All initial looks")),
         var_ordered = factor(variable, levels = fct_lvls, ordered = T))

cleaned_plot_data %>%
  #remove "all initial looks" for target and distractor only types
  filter(!(initial_look == "All initial looks" & variable %in% c("Proportion trials shifting to target", "Proportion trials staying on target", "Reaction time"))) %>%
  mutate(initial_look = case_when(initial_look == "All initial looks" ~ "Combined",
                                  TRUE ~ initial_look)) %>%
  ggplot(aes(x = term, y = fct_rev(var_ordered), fill = pr_t)) +
  geom_tile(color = "black") +
  #geom_text(aes(label = round(pr_t, digits = 3))) +
  #geom_text(aes(label = paste('Beta', "==", round(standardized, digits = 3))), parse = TRUE) +
  geom_text(aes(label = round(standardized, digits = 3))) +
  facet_grid(dataset~initial_look) +
  scale_x_discrete(position = "top") +
  scale_fill_gradientn(name = "p-values",
                      limits = c(0,1),
                      colors = c("#479a28", "#b4e6a1", "#FFFFFF"),
                      values = c(0, .1, 1),
                      breaks = c(0, .1, .9), 
                      labels = c("significant", "marginal", "not significant")) +
  theme_minimal() +
  theme(strip.placement = 'outside',
        axis.title = element_blank(),
        strip.text = element_text(face="bold"),
        panel.grid = element_blank(),
        panel.spacing = unit(1.5, "lines")) +
  guides(
    #reverse color order (higher value on top)
    fill = guide_colorbar(reverse = TRUE)) +
  ggtitle("Standardized Beta coefficients for linear model estimates")

ggsave(here("figures/model_betas_plot.png"), width = 9, height = 6, bg = "white")


print_list[[paste("Model Summaries")]] <- model_summaries 

print_list[[paste("Model comparisons - simple models")]] <- mod_comparisons_simple
print_list[[paste("Model comparisons - interaction models")]] <- mod_comparisons_inter

```

#Models - Mixed Effects

```{r}

library(lme4)
library(glmmTMB)
library(lmerTest)

#use trial-level data for lmems
data_by_trial_long_split <- data_by_trial %>%
  #filter(exp_type == "both_types") %>%
  dplyr::select(data_split, data_source, exp_type, dataset_name, subject_id, age_months, age_months_centred, exp_to_target_lang, eng_exp, fre_exp, target_word, prop_looking:longest_look_by_trial, peak_pupil_size_difference, mean_pupil_size_difference, peak_pupil_latency) %>%
  pivot_longer(12:ncol(.), names_to = "variable", values_to = "response") %>%
  #scale the predictor variables to standardize before doing the models
  mutate(exp_to_target_lang = exp_to_target_lang/100) %>%
  group_by(data_split, exp_type, data_source, variable) %>%
  mutate(across(c(exp_to_target_lang, age_months), scale)) %>%
  ungroup() %>%
  split(f = paste0(.$data_split, "_", .$exp_type, "_", .$data_source, "_", .$variable))

list_levels_1_lmem <- unique(str_remove(names(data_by_trial_long_split), "(?<=peekbank|archival).*"))

#create list structure to house models and model summaries
#------------models
models_lmem <- list()
models_lmem[list_levels_1_lmem] <- list(NULL)

list_levels_2_lmem <- list(simple = NULL)

for (i in 1:length(models_lmem)) {
  models_lmem[[i]] <- list_levels_2_lmem
}
#------------model summaries
model_summaries_lmem <- list()
model_summaries_lmem[list_levels_1_lmem] <- list(NULL)

for (i in 1:length(model_summaries_lmem)) {
  model_summaries_lmem[[i]] <- list_levels_2_lmem
}
#------------plots
#inter_plots_lmem <- list()

for (i in 1:length(data_by_trial_long_split)) {
  data <- data_by_trial_long_split[[i]] 
  element <- str_remove(names(data_by_trial_long_split[i]), "(?<=peekbank|archival).*")
  var_name <- unique(data$variable)
  
  #Skip the loop for variables that area all NA (like the pupil ones in the peekbank data)
  if (sjmisc::all_na(data$response)) {
    next
  } else {
    
  print(paste(element, var_name))
    
    #For archival data only, include lang exposure
    if (str_detect(element, "archival")) {
      
      #--------------------------------------------------------------------Simple model
      #prop looking variables and mean/peak pupil get regular lmer
      if(var_name %in% c("prop_looking", "prop_looking_diff", "mean_pupil_size_difference", "peak_pupil_size_difference")) {
        simple_lmem <- glmmTMB(response ~ age_months + exp_to_target_lang + (1|dataset_name/subject_id),
                                  data = data, family = gaussian(link = 'log'))
        simple_lmem_sum <- summary(simple_lmem)
      #switch to or stay on target get binomial
      } else if (var_name %in% c("correct_shift", "remain_on_target")) {
        simple_lmem <- glmmTMB(response ~ age_months + exp_to_target_lang + (1|dataset_name/subject_id),
                                  data = data, family = binomial,  control = glmmTMBControl())
        simple_lmem_sum <- summary(simple_lmem)
      #aoi switches get zero inflated poisson
      } else if (var_name %in% c("total_aoi_switches")) {
        simple_lmem <- glmmTMB(response ~ age_months + exp_to_target_lang + (1|dataset_name/subject_id),
                                  data = data, family = poisson, ziformula=~1, control = glmmTMBControl())
        simple_lmem_sum <- summary(simple_lmem)
      #number fixations gets regular poisson
      } else if (var_name %in% c("number_fixations")) {
        simple_lmem <- glmmTMB(response ~ age_months + exp_to_target_lang + (1|dataset_name/subject_id),
                                  data = data, family = poisson, control = glmmTMBControl())
        simple_lmem_sum <- summary(simple_lmem)
      #RT, duration of looks, and pupil latency get gamma log link
      } else if (var_name %in% c("latency_to_switch", "duration_of_look", "first_look_dur", "longest_look_by_trial", "peak_pupil_latency")) {
        simple_lmem <- glmmTMB(response ~ age_months + exp_to_target_lang + (1|dataset_name/subject_id),
                                  data = data, family = Gamma(link = "log"), control = glmmTMBControl())
        simple_lmem_sum <- summary(simple_lmem)
      }
        
        add_simple <- list(simple_lmem)
        names(add_simple) <- var_name
        models_lmem[[paste0(element)]]$simple <- c(models_lmem[[paste0(element)]]$simple, add_simple)
        
        add_simple_sum = list(simple_lmem_sum)
        names(add_simple_sum) <- var_name
        model_summaries_lmem[[paste0(element)]]$simple <- c(model_summaries_lmem[[paste0(element)]]$simple, add_simple_sum)
        
    } else {
        #--------------------------------------------------------------------Simple model with age only
      #prop looking variables and mean/peak pupil get regular lmer
      if(var_name %in% c("prop_looking", "prop_looking_diff", "mean_pupil_size_difference", "peak_pupil_size_difference")) {
        simple_lmem <- glmmTMB(response ~ age_months + (1|dataset_name/subject_id),
                                  data = data, family = gaussian (link = 'log'))
        simple_lmem_sum <- summary(simple_lmem)
      #switch to or stay on target get binomial
      } else if (var_name %in% c("correct_shift", "remain_on_target")) {
        simple_lmem <- glmmTMB(response ~ age_months + (1|dataset_name/subject_id),
                                  data = data, family = binomial,  control = glmmTMBControl())
        simple_lmem_sum <- summary(simple_lmem)
      #aoi switches get zero inflated poisson
      } else if (var_name %in% c("total_aoi_switches")) {
        simple_lmem <- glmmTMB(response ~ age_months + (1|dataset_name/subject_id),
                                  data = data, family = poisson, ziformula=~1, control = glmmTMBControl())
        simple_lmem_sum <- summary(simple_lmem)
      #number fixations gets regular poisson
      } else if (var_name %in% c("number_fixations")) {
        simple_lmem <- glmmTMB(response ~ age_months + (1|dataset_name/subject_id),
                                  data = data, family = poisson, control = glmmTMBControl()) 
        simple_lmem_sum <- summary(simple_lmem)
      #RT, duration of looks, and pupil latency get gamma log link
      } else if (var_name %in% c("latency_to_switch", "duration_of_look", "first_look_dur", "longest_look_by_trial", "peak_pupil_latency")) {
        simple_lmem <- glmmTMB(response ~ age_months + (1|dataset_name/subject_id),
                                  data = data, family = Gamma(link = "log"), control = glmmTMBControl())
        simple_lmem_sum <- summary(simple_lmem)
      }
        
        add_simple <- list(simple_lmem)
        names(add_simple) <- var_name
        models_lmem[[paste0(element)]]$simple <- c(models_lmem[[paste0(element)]]$simple, add_simple)
        
        add_simple_sum = list(simple_lmem_sum)
        names(add_simple_sum) <- var_name
        model_summaries_lmem[[paste0(element)]]$simple <- c(model_summaries_lmem[[paste0(element)]]$simple, add_simple_sum)
    }
  }
}

#------------------------------see which ones have convergence issues

model_names <- character()
model_warnings <- character()

for(i in 1:length(models_lmem)) {
  level1_name <- names(models_lmem[i])
  for(j in 1:length(models_lmem[[i]]$simple)) {
    level2_name <- names(models_lmem[[i]]$simple[j])
    model_names <- c(model_names, paste0(level1_name, "...", level2_name))
    warnings <- glue::glue_collapse(model_summaries_lmem[[i]]$simple[[j]]$optinfo$conv$lme4$messages, sep = "; ")
    model_warnings <- c(model_warnings, warnings)
  }
}

warnings <- tibble(model = model_names,
       warnings = model_warnings) %>% 
  separate(model, into = c("model", "variable"), sep = "\\.\\.\\.") %>% 
  mutate(any_warning = ifelse(warnings == "", "no", "yes")) %>% 
  count(variable, any_warning) %>% 
  pivot_wider(names_from = "any_warning", values_from = "n") 

warnings_sum <- warnings %>%
  summarise(no = sum(no, na.rm = T), yes = sum(yes, na.rm = T)) %>%
  mutate(variable = "TOTAL")

warnings %>%
  bind_rows(warnings_sum) %>%
  rename(no_warning = no, warning = yes)

# Check some variables and models
# "all_both_types_archival latency_to_switch"
hist(data_by_trial_long_split$all_both_types_archival_latency_to_switch$response)
hist(data_by_trial_long_split$all_both_types_archival_latency_to_switch$age_months)
hist(data_by_trial_long_split$all_both_types_archival_latency_to_switch$exp_to_target_lang)

hist(data_by_trial_long_split$all_both_types_peekbank_latency_to_switch$response)
hist(data_by_trial_long_split$all_both_types_peekbank_latency_to_switch$age_months)

# Calculate variance and mean
var_latency <- var(df_all_both_types_archival_latency_to_switch$response, na.rm = T)
mean_latency <- mean(df_all_both_types_archival_latency_to_switch$response, na.rm = T)
# Variance-to-mean ratio
var_mean_ratio <- var_latency / mean_latency # overdispersion

df_all_both_types_archival_latency_to_switch <- as.data.frame(data_by_trial_long_split$all_both_types_archival_latency_to_switch) #%>% 
# filter(dataset_name != "CogMisp-24") # lots of NA

df_all_both_types_peekbank_latency_to_switch <- as.data.frame(data_by_trial_long_split$all_both_types_peekbank_latency_to_switch) 

summary_na <- df_all_both_types_archival_latency_to_switch %>% 
  filter(!is.na(response)) %>% 
  group_by(dataset_name, subject_id) %>% 
  summarise(count_na = n_distinct(target_word)) %>% 
  group_by(dataset_name) %>% 
  summarise(total_na = sum(count_na))

modzigamma_archival_latency_switch <- glmmTMB(response ~ age_months + exp_to_target_lang + (1|dataset_name/subject_id),
                                  data = df_all_both_types_archival_latency_to_switch, 
                                  family = ziGamma(link = 'log'), # not converging
                                 ziformula = ~1, # account for many 0s
                                  control = glmmTMBControl(optCtrl=list(iter.max=1e3,eval.max=1e3)))
summary(modzigamma_archival_latency_switch)

modnbinom_archival_latency_switch <- glmmTMB(response ~ age_months + exp_to_target_lang + (1|dataset_name/subject_id),
                                  data = df_all_both_types_archival_latency_to_switch, 
                                 # family = Gamma(link = 'log'), # use gamma if Cogmisp is filtered out
                                 family = nbinom2(),
                                 ziformula = ~1, # account for many 0s
                                #family = poisson(),
                                  control = glmmTMBControl(optCtrl=list(iter.max=1e3,eval.max=1e3)))

summary(modnbinom_archival_latency_switch)

modnbinom1_archival_latency_switch <- glmmTMB(response ~ age_months + exp_to_target_lang + (1|dataset_name/subject_id),
                                  data = df_all_both_types_archival_latency_to_switch, 
                                  family = nbinom1(), 
                                  control = glmmTMBControl())

summary(modnbinom1_archival_latency_switch) # very similar AIC

# Model tests
als <- DHARMa::simulateResiduals(modnbinom_archival_latency_switch, plot = T)
DHARMa::testDispersion(als)
DHARMa::testZeroInflation(als)

# Calculate variance and mean
var_latency <- var(df_all_both_types_peekbank_latency_to_switch$response, na.rm = T)
mean_latency <- mean(df_all_both_types_peekbank_latency_to_switch$response, na.rm = T)
# Variance-to-mean ratio
var_mean_ratio <- var_latency / mean_latency # also overdispersion

modGamm_peekbank_latency_switch <- glmmTMB(response ~ age_months + (1|dataset_name/subject_id),
                                  data = df_all_both_types_peekbank_latency_to_switch, 
                                  family = Gamma(link = "log"), 
                                  control = glmmTMBControl())

summary(modGamm_peekbank_latency_switch)

modnbinom_peekbank_latency_switch <- glmmTMB(response ~ age_months + (1|dataset_name/subject_id),
                                  data = df_all_both_types_peekbank_latency_to_switch, 
                                 family = nbinom2(),
                                 ziformula = ~1, 
                                  control = glmmTMBControl())

summary(modnbinom_peekbank_latency_switch)
# Model tests
# This model checks are not very good, the model is not converging as linear
pls <- DHARMa::simulateResiduals(modnbinom_peekbank_latency_switch, plot = T)
DHARMa::testDispersion(pls)
DHARMa::testZeroInflation(pls)

# "all_experimental_archival first_look_dur"

# "all_non-experimental_archival latency_to_switch"

# "distractor_both_types_archival latency_to_switch"

# "distractor_non-experimental_archival latency_to_switch"

# "distractor_experimental_archival longest_look_by_trial"
# "target_experimental_archival longest_look_by_trial"

# longest_look_by_trial
hist(data_by_trial_long_split$distractor_experimental_archival_longest_look_by_trial$response)
hist(data_by_trial_long_split$target_experimental_archival_longest_look_by_trial$response)

df_distractor_experimental_archival_longest_look_by_trial <- as.data.frame(data_by_trial_long_split$distractor_experimental_archival_longest_look_by_trial) 

modGamm_dist_arch_longest_look <- glmmTMB(response ~ age_months + exp_to_target_lang + (1|dataset_name/subject_id),
                                  data = df_distractor_experimental_archival_longest_look_by_trial, 
                                 family = gaussian(link = "log"), 
                                  control = glmmTMBControl())

summary(modGamm_dist_arch_longest_look)
# Test model
alk <- DHARMa::simulateResiduals(modGamm_archival_long_look, plot = T)
DHARMa::testDispersion(alk)
DHARMa::testZeroInflation(alk)

df_all_both_types_peekbank_longest_look_by_trial <- as.data.frame(data_by_trial_long_split$all_both_types_peekbank_longest_look_by_trial) 

modGamm_peekbank_long_look <- glmmTMB(response ~ age_months + (1|dataset_name/subject_id),
                                  data = df_all_both_types_peekbank_longest_look_by_trial, 
                                 family = Gamma(link = "log"), 
                                  control = glmmTMBControl())

summary(modGamm_peekbank_long_look)
# Test model
plk <- DHARMa::simulateResiduals(modGamm_peekbank_long_look, plot = T)
DHARMa::testDispersion(plk)
DHARMa::testZeroInflation(plk)

# number fixations
hist(data_by_trial_long_split$all_both_types_archival_number_fixations$response)
hist(data_by_trial_long_split$all_both_types_peekbank_number_fixations$response)

df_all_both_types_archival_number_fixations <- as.data.frame(data_by_trial_long_split$all_both_types_archival_number_fixations) 


modGamm_archival_num_fixations <- glmmTMB(response ~ age_months + exp_to_target_lang + (1|dataset_name/subject_id),
                                  data = df_all_both_types_archival_number_fixations, 
                                  family = poisson, 
                                  control = glmmTMBControl())

summary(modGamm_archival_num_fixations)
# Model tests
a2 <- DHARMa::simulateResiduals(modGamm_archival_num_fixations, plot = T)
DHARMa::testDispersion(a2)
DHARMa::testZeroInflation(a2)
DHARMa::testQuantiles(a2)
DHARMa::plotResiduals(a2)

df_all_both_types_peekbank_number_fixations <- as.data.frame(data_by_trial_long_split$all_both_types_peekbank_number_fixations) 

modGamm_peekbank_num_fixations <- glmmTMB(response ~ age_months + (1|dataset_name/subject_id),
                                  data = df_all_both_types_peekbank_number_fixations, 
                                  family = poisson, 
                                  control = glmmTMBControl())

summary(modGamm_peekbank_num_fixations)
# Model tests
a3 <- DHARMa::simulateResiduals(modGamm_peekbank_num_fixations, plot = T)
DHARMa::testDispersion(a3)
DHARMa::testZeroInflation(a3)
DHARMa::testQuantiles(a3)
DHARMa::plotResiduals(a3)

```


#Effect Size
```{r}

#-------------------------------------------------------------Cohen's D's

#Same as for ICC, do this by study, then take the average and include standard errors in the plot

experimental_means_sds <- data_by_subject %>%
  filter(exp_type == "experimental") %>%
  dplyr::select(-contains("exp"), -data_split_id)
non_experimental_means_sds <- data_by_subject %>%
  filter(exp_type == "non-experimental") %>% 
  dplyr::select(-contains("exp"), -data_split_id)

# for_cohens_d <- experimental_means_sds %>%
#   inner_join(non_experimental_means_sds, by=c("data_source", "recording_name", "subject_id", "dataset_name", "age_months", "age_months_centred", "data_split"),
#              suffix = c("_exper", "_nonexper"))

#establish a critical value for alpha = 0.05 to later calculate 95% confidence intervals

crit_value<- qnorm(1-((0.05)/(2)))

#---------------------------------------HK note: make data long with column indicating analysis dataset type (experimental versus non), one column for means, one for SDs, then can calculate Cohen's D by row for each variable type. Put both means SDs dataframes into one dataframe.
experimental_means_sds_long <- experimental_means_sds %>%
  pivot_longer(c(starts_with("mean_"), starts_with("sd_"), starts_with("n_trials_")), names_to = "variable", values_to = "value") %>%
  separate(variable, into = c("var_type", "variable"), sep = "(?<=^mean|sd|n_trials)_") %>%
  mutate(var_type = paste0("experimental_", var_type)) %>%
  pivot_wider(names_from = "var_type", values_from = "value")

non_experimental_means_sds_long <- non_experimental_means_sds %>%
 pivot_longer(c(starts_with("mean_"), starts_with("sd_"), starts_with("n_trials_")), names_to = "variable", values_to = "value") %>%
  separate(variable, into = c("var_type", "variable"), sep = "(?<=^mean|sd|n_trials)_") %>%
  mutate(var_type = paste0("non_experimental_", var_type)) %>%
  pivot_wider(names_from = "var_type", values_from = "value") 


cohens_ds <- experimental_means_sds_long %>%
  inner_join(non_experimental_means_sds_long %>% dplyr::select(dataset_name, recording_name, age_months, data_split, data_source, variable, contains("_mean"), contains("_sd"), contains("_n_trials"))) 

#These kids are in the experimental dataset but not the non-experimental one, so cannot calculate Cohen's D:
experimental_means_sds %>% filter(recording_name %notin% non_experimental_means_sds$recording_name) %>% count(recording_name)
#These kids are in the non-experimental dataset but not the experimental one, so cannot calculate Cohen's D:
non_experimental_means_sds %>% filter(recording_name %notin% experimental_means_sds$recording_name) %>% count(recording_name)

cohens_ds_all_variables <- cohens_ds %>% 
  group_by(dataset_name, data_split, variable) %>% 
  dplyr::summarize(n_experimental = sum(!is.na(experimental_mean)),
                   n_non_experimental = sum(!is.na(non_experimental_mean)), 
                   experimental_means = mean(experimental_mean, na.rm=T),
                   non_experimental_means = mean(non_experimental_mean, na.rm=T),
                   experimental_sd = sd(experimental_mean, na.rm=T),
                   non_experimental_sd = sd(non_experimental_mean, na.rm=T)) %>% 
  rename(experimental_mean = experimental_means, 
         non_experimental_mean = non_experimental_means) %>%
  mutate(pooled_sd = sqrt((((n_experimental-1)*(experimental_sd^2))+((n_non_experimental-1)*(non_experimental_sd^2)))/((n_experimental+n_non_experimental)-2))) %>%
  mutate(cohen_d = (experimental_mean-non_experimental_mean)/pooled_sd) %>%
  mutate(SE=sqrt(((n_experimental+n_non_experimental)/(n_experimental*n_non_experimental))+
                        ((cohen_d^2)/(2*(n_experimental+n_non_experimental))))) %>%
  mutate(CI_lower = (cohen_d-(crit_value*SE))) %>%
  mutate(CI_upper = (cohen_d+(crit_value*SE))) %>% 
  ungroup() %>%
  mutate(across(c(cohen_d, CI_lower, CI_upper), abs)) %>%
  filter(!is.nan(experimental_mean) & !is.nan(non_experimental_mean)) %>%
  ungroup() %>%
  split(f = paste0(.$data_split, "_", .$variable))

#use inverse variance weighting to pool the effect sizes and CIs
#standardized mean differences
smds <- list()

for (i in 1:length(cohens_ds_all_variables)) {
  element <- names(cohens_ds_all_variables[i])
  data <- cohens_ds_all_variables[[i]] 
  smd <- metafor::escalc(measure = "SMD", 
                         m1i = experimental_mean,
                         sd1i = experimental_sd,
                         n1i = n_experimental,
                         m2i = non_experimental_mean,
                         sd2i = non_experimental_sd,
                         n2i = n_non_experimental,
                         data = data,
                         correct = T) %>%
  mutate(yi = abs(yi))
  
  smds[paste0(element)] <- list(smd)
    
}

means_cis <- list()

for (i in 1:length(smds)) {
  
  element <- names(smds[i])
  data <- smds[[i]]
  vals <- metafor::rma(yi, vi, data = data)
  meta_values <- tibble(var = element,
                        st_mean_diff = vals$beta[[1]],
                        ci_low = vals$ci.lb,
                        ci_high = vals$ci.ub,
                        p_val = vals$pval)
  means_cis[[paste0(element)]] <- meta_values
  
}

# #Create effect size visualization

fct_lvls <- c("Proportion looking", "Proportion looking difference", "Number fixations", "Proportion trials shifting to target", "Proportion trials staying on target", "Reaction time", "Mean number of AOI switches", "Mean duration of all looks", "Duration of first look", "Duration of longest look", "Peak pupil size difference", "Mean pupil size difference", "Peak pupil latency")

smds_for_plot <- means_cis %>%
  bind_rows() %>%
  mutate(var = str_replace(var, "_", ".")) %>%
  separate(var, into = c("data_split", "variable"), sep = "\\.") %>%
  mutate(variable = case_when(variable == "RT" ~ "Reaction time",
                              variable == "duration_of_look" ~ "Mean duration of all looks",
                              variable == "first_look_dur" ~ "Duration of first look",
                              variable == "longest_look" ~ "Duration of longest look",
                              variable == "prop_shift_distractor_initial" ~ "Proportion trials shifting to target",
                              variable == "prop_shift_target_initial" ~ "Proportion trials staying on target",
                              variable == "prop_looking" ~ "Proportion looking",
                              variable == "prop_looking_diff" ~ "Proportion looking difference",
                              variable == "aoi_switches" ~ "Mean number of AOI switches",
                              TRUE ~ snakecase::to_sentence_case(variable)),
         data_split = case_when(data_split == "all" ~ "Combined",
                                TRUE ~ snakecase::to_sentence_case(data_split)),
         data_split = factor(snakecase::to_sentence_case(data_split), levels = c("Target", "Distractor", "Combined")),
         var_ordered = factor(variable, levels = fct_lvls, ordered = T))


smds_for_plot %>%
  #remove "all initial looks" for target and distractor only types
  filter(!(data_split == "All initial looks" & variable %in% c("Proportion trials shifting to target", "Proportion trials staying on target", "Reaction time"))) %>%
  ggplot(aes(x = st_mean_diff, y = fct_rev(var_ordered), color = data_split)) +
  geom_vline(xintercept = 0, color = "#777777", linetype = "dotted") +
  geom_errorbar(aes(xmin = ci_low, xmax = ci_high), alpha = .75, width = .25) +
  geom_point(size=4, alpha = .75, shape = 18)+
  #geom_errorbarh(aes(xmin=all_dvs_c$CI_lower, xmax=all_dvs_c$CI_upper))+
  labs(x = "Pooled effect Size",
       y = "Variable",
       title = "Distribution of Standardized Mean Differences by variable\n(Experimental vs familiar trials)",
       color = "Initial look location") +
  theme_minimal()+
  theme(plot.background = element_rect(fill = "white"),
        panel.spacing = unit(2, "lines"),
        panel.grid = element_line(color = "#EEEEFF")) +
  scale_x_continuous(limits = c(-1,1)) +
  scale_color_manual(values = c("#438e32", "#c82a85", "#333333")) 


ggsave(here::here(paste0("figures/effect_size_plot.png")), height = 5, width = 8)


```





```{r}
#Save the print_list to a text file

sink(file = here(paste0("code_printout.txt"))); print(print_list); sink()

read_csv(here(paste0(
     "all_variables_datasets/archival_by_subject_means_sds_experimental_target.csv"))) %>% nrow()

```

